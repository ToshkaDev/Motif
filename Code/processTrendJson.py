#!/usr/bin/python
import sys, getopt
import json
import collections
import re


USAGE = "\n\n The script processes domains in domains json file generated by TREND.\n\n" + \
	"python 	" + sys.argv[0] + '''
	-h || --help               - help
	-i || --ifile              - input file with domains information in json format
	-o || --ofile              - output file with domains
	-a || --afile              - output file with architectures and their counts
	-g || --gfile              - output file with organisms
	'''

INPUT_FILE = None
OUTPUT_FILE = None
OUTPUT_FILE_ARCHITECTURES = None
OUTPUT_FILE_ORGANISMS = None

REG = re.compile(r'(?<=_)[A-Z][a-z]{1,}_[a-z][a-z]')

PROTEIN_TO_DOMAINS = collections.defaultdict(list)
MCP_CLASSES = set(("64H", "58H", "52H", "48H", "44H", "42H", "40H", "38H", "36H", "34H", "28H", "24H"))
DOMAIN_ARCHITECTURE_TO_ORGANISMS = collections.defaultdict(list) 

def initialize(argv):
	global INPUT_FILE, OUTPUT_FILE, OUTPUT_FILE_ARCHITECTURES, OUTPUT_FILE_ORGANISMS
	try:
		opts, args = getopt.getopt(argv[1:],"hi:o:a:g:",["help", "ifile=", "ofile=", "afile=", "gfile="])
		if len(opts) == 0:
			raise getopt.GetoptError("Options are required\n")
	except getopt.GetoptError as e:
		print "===========ERROR==========\n " + str(e) + USAGE
		sys.exit(2)
	try:
		for opt, arg in opts:
			if opt in ("-h", "--help"):
				print USAGE
				sys.exit()
			elif opt in ("-i", "--ifile"):
				INPUT_FILE = str(arg).strip()
			elif opt in ("-o", "--ofile"):
				OUTPUT_FILE = str(arg).strip()
			elif opt in ("-a", "--afile"):
				OUTPUT_FILE_ARCHITECTURES = str(arg).strip()
			elif opt in ("-g", "--gfile"):
				OUTPUT_FILE_ORGANISMS = str(arg).strip()
	except Exception as e:
		print "===========ERROR==========\n " + str(e) + USAGE
		sys.exit(2)



def loadJSON():
	try:
		with open(INPUT_FILE, "r") as inputFile:
			result = json.loads(inputFile.read())
	except Exception as e:
		result = None
		print("Exception happened whyle trying to decode json: " + str(e))
		print("So returning None")
	finally:
		return result
	
		
def processDomains(result):
	mcpClassToCount = collections.defaultdict(int)	
	for protein, info in result.items():
		if "domainsWithNoOverlaps" in info:
			isMcp = False
			for domain in info["domainsWithNoOverlaps"]:
				PROTEIN_TO_DOMAINS[protein].append(domain["domainName"])
				if domain["domainName"] in MCP_CLASSES:
					if not isMcp:
						mcpClassToCount[domain["domainName"]]+=1
					isMcp = True
			#if isMcp:
				#PROTEIN_TO_DOMAINS[protein].append("M_MCP")	
	mcpClassToCountSorted = sorted(mcpClassToCount.items(), key=lambda domArch: domArch[1], reverse=True)	
	domainArchitectureToCounts = processDomainArchitectures()
	return (domainArchitectureToCounts, mcpClassToCountSorted)
				
				
def processDomainArchitectures():
	domainArchitectureToCounts = collections.defaultdict(int)
	proteinDomains = PROTEIN_TO_DOMAINS.copy()
	for protein, domains in proteinDomains.items():
		pasIsPresent = False
		domainsToSave = []
		for domain in domains:
			if ("_" in domain and domain.split("_")[0] == "PAS") or (domain == "PAS"):
				if not pasIsPresent:
					pasIsPresent = True
					domainsToSave.append("PAS")
			else:
				if domain != "HAMP":
					domainsToSave.append(domain)
				
		
		domainsToSaveStr = ",".join(sorted(domainsToSave))
		domainArchitectureToCounts[domainsToSaveStr]+=1
		organismMatch = list(re.finditer(REG, protein))
		if len(organismMatch):
			startOfOrgsmName = list(re.finditer(REG, protein))[-1].start()
			organism = " ".join(protein[startOfOrgsmName:].split("_"))
		else:
			organism = protein
		DOMAIN_ARCHITECTURE_TO_ORGANISMS[domainsToSaveStr].append(organism)
	return sorted(domainArchitectureToCounts.items(), key=lambda domArch: domArch[1], reverse=True)		


def saveFile(domainArchitectureToCounts, mcpClassToCountSorted):
	with open(OUTPUT_FILE, "w") as outputFile:
		for protein, domains in PROTEIN_TO_DOMAINS.items():
			outputFile.write(protein + "\t" + "\t".join(domains) + "\n")
	with open(OUTPUT_FILE_ARCHITECTURES, "w") as archOutputFile:
		for mcpClassCount in mcpClassToCountSorted:
			archOutputFile.write(mcpClassCount[0] + "\t" + str(mcpClassCount[1]) + "\n")
	with open(OUTPUT_FILE_ARCHITECTURES, "a") as archOutputFile:
		for architectureCount in domainArchitectureToCounts:
			archOutputFile.write(architectureCount[0] + "\t" + str(architectureCount[1]) + "\n")	
	with open(OUTPUT_FILE_ORGANISMS, "w") as orgOutputFile:
		for architecture, organismList in DOMAIN_ARCHITECTURE_TO_ORGANISMS.items():
			for organism in organismList:
				orgOutputFile.write(architecture + "\t" + organism + "\n")		

		 
def main(argv):
	initialize(argv)
	result = loadJSON()
	if result != None:
		domainArchitectureToCounts, mcpClassToCountSorted = processDomains(result)
		saveFile(domainArchitectureToCounts, mcpClassToCountSorted)
		
if __name__ == "__main__":
	main(sys.argv)
